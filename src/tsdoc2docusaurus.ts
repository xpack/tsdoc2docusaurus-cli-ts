/*
 * This file is part of the xPack project (http://xpack.github.io).
 * Copyright (c) 2025 Liviu Ionescu. All rights reserved.
 *
 * Permission to use, copy, modify, and/or distribute this software
 * for any purpose is hereby granted, under the terms of the MIT license.
 *
 * If a copy of the license was not distributed with this file, it can
 * be obtained from https://opensource.org/licenses/MIT.
 */

import path from 'path'
import fs from 'fs/promises'
import {
  SidebarCategory,
  SidebarCategoryItem,
  SidebarDocItem,
} from './docusaurus/types.js'
// import util from 'util'

// This script is a tool to rewrite some parts of the docs generated
// by api-generator and api-documenter so they work with the website
// generated by Docusaurus.

// This runs in the website folder.
const apiJsonFilePath = '../api-extractor/doxygen2docusaurus.api.json'
const sidebarFilePath = 'sidebar-category-tsdoc.json'

const inputFolderPath = '../api-extractor/markdown'
const docsRelativeFolderPath = 'docs'
const apiRelativeFolderPath = 'api'
const outputFolderPath = `${docsRelativeFolderPath}/${apiRelativeFolderPath}`

const baseUrl = '/doxygen2docusaurus-ts/'

interface EntryPoint {
  kind: string

  inputFilePath: string
  permalink: string

  frontMatterSlug: string
  frontMatterTitle: string

  sidebarLabel: string
  sidebarId: string

  outputFilePath: string

  // Map of array of compounds, by kind (Class, Interface, ...)
  compoundsMap: Map<string, Compound[]>
  data: any
}

interface Compound {
  kind: string

  inputFilePath: string
  permalink: string

  frontMatterSlug: string
  frontMatterTitle: string

  sidebarLabel: string
  sidebarId: string

  outputFilePath: string

  membersMap: Map<string, Member[]> // Map of array of members, by kind (Constructor, Property, ...)
  data: any
}

interface Member {
  kind: string

  inputFilePath: string
  permalink: string

  frontMatterSlug: string
  frontMatterTitle: string

  sidebarLabel: string
  sidebarId: string

  outputFilePath: string
  isHidden?: boolean

  data: any
}

interface FrontMatter {
  slug: string
  title: string
}

interface TopIndex {
  kind: string

  inputFilePath: string
  permalink: string

  frontMatterSlug: string
  frontMatterTitle: string

  sidebarLabel: string
  sidebarId: string

  outputFilePath: string
}

type EntryPointsSet = Set<EntryPoint>

interface ApiViewModel {
  topIndex: TopIndex
  entryPointsSet: EntryPointsSet
  permalinksMapByPath: Map<string, string>
}
// ----------------------------------------------------------------------------

async function parseApiDataModel(): Promise<any | null> {
  // Parse the API JSON file
  let apiDataModel: any = null
  try {
    const apiJsonContent = await fs.readFile(apiJsonFilePath, 'utf8')
    apiDataModel = JSON.parse(apiJsonContent)
  } catch (err) {
    if (err instanceof Error) {
      console.warn(
        `Could not parse API JSON file ${apiJsonFilePath}: ${err.message}`
      )
    } else {
      console.warn(
        `Could not parse API JSON file ${apiJsonFilePath}: Unknown error`
      )
    }
    return null
  }

  return apiDataModel
}

// ----------------------------------------------------------------------------

function prepareApiViewModel(apiDataModel: any) {
  const entryPointsSet = new Set<EntryPoint>()

  // Key paths do not start with '/', permalinks are absolute (start with baseUrl).
  const permalinksMapByPath = new Map<string, string>()

  const topIndex: TopIndex = {
    kind: 'TopIndex',

    inputFilePath: 'index.md',
    permalink: `${baseUrl}${outputFolderPath}`,

    frontMatterSlug: '/api',
    frontMatterTitle: 'API Reference',

    sidebarLabel: 'API Reference (TSDoc',
    sidebarId: `${apiRelativeFolderPath}/index`,

    outputFilePath: 'index.md',
  }

  permalinksMapByPath.set(topIndex.inputFilePath, topIndex.permalink)

  for (const entryPointDataModel of apiDataModel.members) {
    // console.log(entryPointDataModel.kind, entryPointDataModel.canonicalReference);

    const entryPointKind = entryPointDataModel.kind
    const entryPointLabel = entryPointDataModel.canonicalReference.replace(
      /[!]$/,
      ''
    )
    const entryPointId = entryPointLabel.replace(/^.*\//, '').toLowerCase()

    const inputFilePath = `${entryPointId}.md`
    const permalink = `${baseUrl}${outputFolderPath}/${entryPointId}`
    permalinksMapByPath.set(inputFilePath, permalink)

    const frontMatterSlug = `/api/${entryPointId}`
    const frontMatterTitle = `${entryPointId} package`

    const sidebarLabel = entryPointLabel
    const sidebarId = `${apiRelativeFolderPath}/${entryPointId}`

    const outputFilePath = `${entryPointId}.md`

    const entryPoint: EntryPoint = {
      kind: entryPointKind,

      inputFilePath,
      permalink,

      frontMatterSlug,
      frontMatterTitle,

      sidebarLabel,
      sidebarId,

      outputFilePath,

      compoundsMap: new Map(), // Map of array of compounds, by kind (Class, Interface, ...)
      data: entryPointDataModel,
    }
    entryPointsSet.add(entryPoint)

    for (const compoundDataModel of entryPointDataModel.members) {
      // console.log(compoundDataModel.kind, compoundDataModel.name, compoundDataModel.canonicalReference);

      const compoundKind = compoundDataModel.kind
      const compoundLabel = compoundDataModel.name
      const compoundId = compoundDataModel.name.toLowerCase()

      const compoundCategoryId = pluralise(compoundKind).toLowerCase()

      const inputFilePath = `${entryPointId}.${compoundId}.md`
      const permalink = `${baseUrl}${outputFolderPath}/${entryPointId}/${compoundCategoryId}/${compoundId}`
      permalinksMapByPath.set(inputFilePath, permalink)

      const frontMatterSlug = `/api/${entryPointId}/${compoundCategoryId}/${compoundId}`

      let compoundTitle = compoundLabel
      if (compoundKind === 'Function') {
        compoundTitle += '()'
      }

      const frontMatterTitle = `${compoundTitle} ${compoundKind.toLowerCase()}`

      const sidebarLabel = compoundTitle
      const sidebarId = `${apiRelativeFolderPath}/${entryPointId}/${compoundCategoryId}/${compoundId}`

      const outputFilePath = `${entryPointId}/${compoundCategoryId}/${compoundId}.md`

      const compound: Compound = {
        kind: compoundKind,

        inputFilePath,
        permalink,

        frontMatterSlug,
        frontMatterTitle,

        sidebarLabel,
        sidebarId,

        outputFilePath,

        membersMap: new Map(), // Map of array of members, by kind (Constructor, Property, ...)
        data: compoundDataModel,
      }

      let compoundsArray = entryPoint.compoundsMap.get(compoundDataModel.kind)
      if (compoundsArray === undefined) {
        compoundsArray = []
        entryPoint.compoundsMap.set(compound.kind, compoundsArray)
      }
      compoundsArray.push(compound)

      if (compoundDataModel.members !== undefined) {
        for (const memberDataModel of compoundDataModel.members) {
          // console.log('  ', memberDataModel.kind, memberDataModel.name, memberDataModel.canonicalReference);

          const memberKind = memberDataModel.kind
          let memberLabel = memberDataModel.name

          let originalMemberId = memberDataModel.name

          let memberId
          if (memberLabel !== undefined) {
            originalMemberId = memberLabel
              .replaceAll(/[^a-zA-Z0-9]/g, '_')
              .toLowerCase()

            memberId = originalMemberId
          }

          // const memberCategoryId = pluralise(memberKind).toLowerCase()
          // console.log(memberCategoryId)

          let memberTitle = memberLabel

          if (memberKind === 'Constructor') {
            memberId = 'constructor'
            memberTitle = '(constructor)'
            originalMemberId = '_constructor_'
          }

          // if (originalMemberId === undefined) {
          //   console.log(memberDataModel)
          // }

          const inputFilePath = `${entryPointId}.${compoundId}.${originalMemberId}.md`
          const permalink = `${baseUrl}${outputFolderPath}/${entryPointId}/${compoundCategoryId}/${compoundId}/${memberId}`
          if (memberKind !== 'CallSignature') {
            // if(originalMemberId === undefined) {
            //   console.log(memberDataModel)
            // }
            permalinksMapByPath.set(inputFilePath, permalink)
          }

          const frontMatterSlug = `/api/${entryPointId}/${compoundCategoryId}/${compoundId}/${memberId}`

          if (memberKind === 'Method') {
            memberTitle += '()'
          }

          let titleKind = memberKind
          if (titleKind === 'PropertySignature') {
            titleKind = 'Property'
          }

          let escapedMemberId = memberId
          // Docusaurus ignores files that start with an underscore.
          // Surround with $ if the original name contains non-alphanumeric characters
          if (/^_/.test(originalMemberId)) {
            escapedMemberId = `$${escapedMemberId}$`
          }

          const frontMatterTitle =
            memberKind !== 'Constructor'
              ? `${compoundLabel}.${memberTitle} ${titleKind.toLowerCase()}`
              : `${compoundLabel}.${memberTitle}`

          const sidebarLabel = memberTitle
          const sidebarId = `${apiRelativeFolderPath}/${entryPointId}/${compoundCategoryId}/${compoundId}/${escapedMemberId}`

          const outputFilePath = `${entryPointId}/${compoundCategoryId}/${compoundId}/${escapedMemberId}.md`

          const member: Member = {
            kind: memberKind,

            inputFilePath,
            permalink,

            frontMatterSlug,
            frontMatterTitle,

            sidebarLabel,
            sidebarId,

            outputFilePath,

            data: memberDataModel,
          }

          if (memberId === undefined) {
            member.isHidden = true
          }

          let membersArray = compound.membersMap.get(member.kind)
          if (membersArray === undefined) {
            membersArray = []
            compound.membersMap.set(member.kind, membersArray)
          }

          membersArray.push(member)
        }
      }
    }
  }

  // for (const [keyPath, permalink] of permalinksMapByPath) {
  //   console.log(keyPath, '=>', permalink)
  // }

  return {
    topIndex,
    entryPointsSet,
    permalinksMapByPath,
  }
}

// ----------------------------------------------------------------------------

async function readInputFileLines(filePath: string): Promise<string[]> {
  const inputData = await fs.readFile(filePath, 'utf8')
  return inputData.split('\n').map((line) => line.trimEnd())
}

async function writeOutputFile(
  filePath: string,
  frontMatter: FrontMatter,
  lines: string[]
) {
  const header = [
    '---',
    // '',
    // '# DO NOT EDIT!',
    // '# Automatically generated via tsdoc2docusaurus by API Documenter.',
    // '',
    `slug: ${frontMatter.slug}`,
    `title: ${frontMatter.title}`,
    'custom_edit_url: null',
    '---',
    '',
    '<div class="tsdocPage">',
    '',
  ]

  const footer = ['</div>']

  const outputContent = header.concat(lines).concat(footer).join('\n')
  await fs.mkdir(path.dirname(filePath), { recursive: true })
  await fs.writeFile(filePath, outputContent, 'utf8')
  console.log(`Writing ${filePath}...`)
}

function patchLines(
  lines: string[],
  permalinksMapByPath: Map<string, string>
): string[] {
  const outLines = []

  let firstH2 = false

  for (const line of lines) {
    if (line.match(/^\[Home\]\(\.\/index\.md\)/)) {
      continue // Skip the home link
    } else if (!firstH2 && line.startsWith('## ')) {
      firstH2 = true
      continue
    } else if (line.startsWith('**Signature:**')) {
      // Convert the signature line to a H2
      outLines.push('## Signature')
    } else if (line.startsWith('**Returns:**')) {
      // Convert the returns line to a H2
      outLines.push('## Returns')
    } else {
      // Patch links and other formatting
      outLines.push(patchPermalinks(line, permalinksMapByPath))
    }
  }
  return outLines
}

function patchPermalinks(
  line: string,
  permalinksMapByPath: Map<string, string>
) {
  let patchedLine = line

  const matches = [...line.matchAll(/\]\([^\(<>\)]*\)/g)]
  if (matches.length > 0) {
    // console.log(matches)
    for (const match of matches) {
      const link = match[0]
      const linkPath = link.slice(2, -1) // Remove the leading `](` and trailing `)`
      if (linkPath.startsWith('./')) {
        // Relative link, patch it
        const relativePath = linkPath.slice(2)
        if (permalinksMapByPath.has(relativePath)) {
          const permalink = permalinksMapByPath.get(relativePath)
          // console.log(relativePath, '->', permalink)
          patchedLine = patchedLine.replace(link, `](${permalink})`)
          // console.log(patchedLine)
        } else {
          console.warn(`No permalink for ${relativePath}, skipping patch.`)
        }
      }
    }
  }

  return patchedLine
}

async function generateMdFiles(apiViewModel: ApiViewModel): Promise<void> {
  const entryPointsSet = apiViewModel.entryPointsSet

  {
    const topIndex = apiViewModel.topIndex
    const lines = await readInputFileLines(
      `${inputFolderPath}/${topIndex.inputFilePath}`
    )

    const patchLinesLines = patchLines(lines, apiViewModel.permalinksMapByPath)

    const frontMatter = {
      slug: topIndex.frontMatterSlug,
      title: topIndex.frontMatterTitle,
    }

    await writeOutputFile(
      `${outputFolderPath}/${topIndex.outputFilePath}`,
      frontMatter,
      patchLinesLines
    )
  }

  // --------------------------------------------------------------------------

  for (const entryPoint of entryPointsSet) {
    // console.log(entryPoint)

    const lines = await readInputFileLines(
      `${inputFolderPath}/${entryPoint.inputFilePath}`
    )

    const patchLinesLines = patchLines(lines, apiViewModel.permalinksMapByPath)

    const frontMatter = {
      slug: entryPoint.frontMatterSlug,
      title: entryPoint.frontMatterTitle,
    }

    await writeOutputFile(
      `${outputFolderPath}/${entryPoint.outputFilePath}`,
      frontMatter,
      patchLinesLines
    )

    // ------------------------------------------------------------------------

    for (const [compoundKind, compoundsArray] of entryPoint.compoundsMap) {
      const compoundCategoryLabel = pluralise(compoundKind)
      // console.log(`  ${compoundCategoryLabel}`)

      for (const compound of compoundsArray) {
        // console.log(`    ${compound.label}`)

        const lines = await readInputFileLines(
          `${inputFolderPath}/${compound.inputFilePath}`
        )

        const patchLinesLines = patchLines(
          lines,
          apiViewModel.permalinksMapByPath
        )

        const frontMatter = {
          slug: compound.frontMatterSlug,
          title: compound.frontMatterTitle,
        }

        // TODO: Insert members into compound (future improvement).

        await writeOutputFile(
          `${outputFolderPath}/${compound.outputFilePath}`,
          frontMatter,
          patchLinesLines
        )

        // --------------------------------------------------------------------

        if (compound.membersMap !== undefined && compound.membersMap.size > 0) {
          for (const [memberKind, membersArray] of compound.membersMap) {
            for (const member of membersArray) {
              if (member.isHidden) {
                continue
              }

              // console.log(`      ${member.label} ${member.name} ${member.id}`)

              const lines = await readInputFileLines(
                `${inputFolderPath}/${member.inputFilePath}`
              )

              const patchLinesLines = patchLines(
                lines,
                apiViewModel.permalinksMapByPath
              )

              const frontMatter = {
                slug: member.frontMatterSlug,
                title: member.frontMatterTitle,
              }

              await writeOutputFile(
                `${outputFolderPath}/${member.outputFilePath}`,
                frontMatter,
                patchLinesLines
              )
            }
          }
        }
      }
    }
  }
}

// ----------------------------------------------------------------------------

function generateSidebarCategory(apiViewModel: ApiViewModel) {
  const entryPointsSet = apiViewModel.entryPointsSet

  const topIndex = apiViewModel.topIndex

  const sidebarTopCategory: SidebarCategory = {
    type: 'category',
    label: topIndex.sidebarLabel,
    link: {
      type: 'doc',
      id: topIndex.sidebarId,
    },
    collapsed: false,
    items: [],
  }

  for (const entryPoint of entryPointsSet) {
    const entryPointCategory: SidebarCategory = {
      type: 'category',
      label: entryPoint.sidebarLabel,
      link: {
        type: 'doc',
        id: entryPoint.sidebarId,
      },
      collapsed: false,
      items: [],
    }
    sidebarTopCategory.items.push(entryPointCategory)

    for (const [kind, compoundsArray] of entryPoint.compoundsMap) {
      const compoundCategoryLabel = pluralise(kind)
      const kindCategory: SidebarCategoryItem = {
        type: 'category',
        label: compoundCategoryLabel,
        collapsed: true,
        items: [],
      }
      entryPointCategory.items.push(kindCategory)

      for (const compound of compoundsArray) {
        const compoundCategory: SidebarCategoryItem = {
          type: 'category',
          label: compound.sidebarLabel,
          link: {
            type: 'doc',
            id: compound.sidebarId,
          },
          collapsed: true,
          items: [],
        }
        kindCategory.items.push(compoundCategory)

        if (compound.membersMap !== undefined && compound.membersMap.size > 0) {
          for (const [memberKind, membersArray] of compound.membersMap) {
            for (const member of membersArray) {
              if (member.isHidden) {
                // console.warn(`Skipping member without name in ${compoundLabel}: ${member.data.canonicalReference}`);
                continue
              }

              const memberDoc: SidebarDocItem = {
                type: 'doc',
                id: `${member.sidebarId}`,
                label: member.sidebarLabel,
              }
              compoundCategory.items.push(memberDoc)
            }
          }
        }
      }
    }
  }

  return sidebarTopCategory
}

// ----------------------------------------------------------------------------

function pluralise(name: string): string {
  const plurals: Record<string, string> = {
    Class: 'Classes',
    Interface: 'Interfaces',
    Function: 'Functions',
    Variable: 'Variables',
    'Type alias': 'Type aliases',
    Namespace: 'Namespaces',
    Enum: 'Enums',
    Method: 'Methods',
    Property: 'Properties',
  }

  if (plurals[name] !== undefined) {
    return plurals[name]
  }

  console.warn(`No plural for ${name}, using default.`)
  return name + 's?'
}

// ----------------------------------------------------------------------------

export async function main() {
  // Parse the API JSON file
  const apiDataModel = await parseApiDataModel()
  if (apiDataModel === null) {
    return 1
  }

  const apiViewModel = prepareApiViewModel(apiDataModel)

  const sidebar = generateSidebarCategory(apiViewModel)
  // console.log(util.inspect(sidebar, { compact: false, depth: 999 }));

  // Write the sidebar to file.
  try {
    console.log(`Writing sidebar file ${sidebarFilePath}`)
    const sidebarJson = JSON.stringify(sidebar, null, 2)
    await fs.writeFile(sidebarFilePath, sidebarJson)
  } catch (err: unknown) {
    if (err instanceof Error) {
      console.error(
        `Could not write sidebar file ${sidebarFilePath}: ${err.message}`
      )
    } else {
      console.error(
        `Could not write sidebar file ${sidebarFilePath}: Unknown error`
      )
    }
    return 1
  }

  // process.exit(0);

  await generateMdFiles(apiViewModel)

  // await legacy()

  return 0
}

// ----------------------------------------------------------------------------
