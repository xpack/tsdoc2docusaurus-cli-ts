/*
 * This file is part of the xPack project (http://xpack.github.io).
 * Copyright (c) 2025 Liviu Ionescu. All rights reserved.
 *
 * Permission to use, copy, modify, and/or distribute this software
 * for any purpose is hereby granted, under the terms of the MIT license.
 *
 * If a copy of the license was not distributed with this file, it can
 * be obtained from https://opensource.org/licenses/MIT.
 */
import { pluralise } from '../generate.js';
// import util from 'node:util'
// ----------------------------------------------------------------------------
// This script is a tool to rewrite some parts of the docs generated
// by api-generator and api-documenter so they work with the website
// generated by Docusaurus.
// This runs in the website folder.
export const sidebarFilePath = 'sidebar-category-tsdoc.json';
export const inputFolderPath = '../api-extractor/markdown';
const docsRelativeFolderPath = 'docs';
const apiRelativeFolderPath = 'api';
export const outputFolderPath = `${docsRelativeFolderPath}/${apiRelativeFolderPath}`;
const baseUrl = '/doxygen2docusaurus-ts/';
// ----------------------------------------------------------------------------
// eslint-disable-next-line complexity
export function prepareViewModel(dataModel) {
    const entryPointsSet = new Set();
    // Key paths do not start with '/', permalinks are absolute (start with baseUrl).
    const permalinksMapByPath = new Map();
    const topIndex = {
        kind: 'TopIndex',
        inputFilePath: 'index.md',
        permalink: `${baseUrl}${outputFolderPath}`,
        frontMatterSlug: '/api',
        frontMatterTitle: 'API Reference',
        sidebarLabel: 'API Reference (TSDoc',
        sidebarId: `${apiRelativeFolderPath}/index`,
        outputFilePath: 'index.md',
    };
    permalinksMapByPath.set(topIndex.inputFilePath, topIndex.permalink);
    for (const entryPointDataModel of dataModel.members) {
        // console.log(entryPointDataModel.kind, entryPointDataModel.canonicalReference);
        const entryPointKind = entryPointDataModel.kind;
        const entryPointLabel = entryPointDataModel.canonicalReference.replace(/[!]$/, '');
        const entryPointId = entryPointLabel.replace(/^.*\//, '').toLowerCase();
        const inputFilePath = `${entryPointId}.md`;
        const permalink = `${baseUrl}${outputFolderPath}/${entryPointId}`;
        permalinksMapByPath.set(inputFilePath, permalink);
        const frontMatterSlug = `/api/${entryPointId}`;
        const frontMatterTitle = `${entryPointId} package`;
        const sidebarLabel = entryPointLabel;
        const sidebarId = `${apiRelativeFolderPath}/${entryPointId}`;
        const outputFilePath = `${entryPointId}.md`;
        const entryPoint = {
            kind: entryPointKind,
            inputFilePath,
            permalink,
            frontMatterSlug,
            frontMatterTitle,
            sidebarLabel,
            sidebarId,
            outputFilePath,
            compoundsMap: new Map(), // Map of array of compounds, by kind (Class, Interface, ...)
            data: entryPointDataModel,
        };
        entryPointsSet.add(entryPoint);
        for (const compoundDataModel of entryPointDataModel.members) {
            // console.log(compoundDataModel.kind, compoundDataModel.name, compoundDataModel.canonicalReference);
            const compoundKind = compoundDataModel.kind;
            const compoundLabel = compoundDataModel.name;
            const compoundId = compoundDataModel.name.toLowerCase();
            const compoundCategoryId = pluralise(compoundKind).toLowerCase();
            const inputFilePath = `${entryPointId}.${compoundId}.md`;
            const permalink = `${baseUrl}${outputFolderPath}/${entryPointId}/${compoundCategoryId}/${compoundId}`;
            permalinksMapByPath.set(inputFilePath, permalink);
            const frontMatterSlug = `/api/${entryPointId}/${compoundCategoryId}/${compoundId}`;
            let compoundTitle = compoundLabel;
            if (compoundKind === 'Function') {
                compoundTitle += '()';
            }
            const frontMatterTitle = `${compoundTitle} ${compoundKind.toLowerCase()}`;
            const sidebarLabel = compoundTitle;
            const sidebarId = `${apiRelativeFolderPath}/${entryPointId}/${compoundCategoryId}/${compoundId}`;
            const outputFilePath = `${entryPointId}/${compoundCategoryId}/${compoundId}.md`;
            const compound = {
                kind: compoundKind,
                inputFilePath,
                permalink,
                frontMatterSlug,
                frontMatterTitle,
                sidebarLabel,
                sidebarId,
                outputFilePath,
                membersMap: new Map(), // Map of array of members, by kind (Constructor, Property, ...)
                data: compoundDataModel,
            };
            let compoundsArray = entryPoint.compoundsMap.get(compoundDataModel.kind);
            if (compoundsArray === undefined) {
                compoundsArray = [];
                entryPoint.compoundsMap.set(compound.kind, compoundsArray);
            }
            compoundsArray.push(compound);
            if (compoundDataModel.members !== undefined) {
                for (const memberDataModel of compoundDataModel.members) {
                    // console.log('  ', memberDataModel.kind, memberDataModel.name, memberDataModel.canonicalReference);
                    const memberKind = memberDataModel.kind;
                    const memberLabel = memberDataModel.name;
                    let originalMemberId = memberDataModel.name;
                    let memberId;
                    if (memberLabel !== undefined) {
                        originalMemberId = memberLabel
                            .replaceAll(/[^a-zA-Z0-9]/g, '_')
                            .toLowerCase();
                        memberId = originalMemberId;
                    }
                    // const memberCategoryId = pluralise(memberKind).toLowerCase()
                    // console.log(memberCategoryId)
                    let memberTitle = memberLabel;
                    if (memberKind === 'Constructor') {
                        memberId = 'constructor';
                        memberTitle = '(constructor)';
                        originalMemberId = '_constructor_';
                    }
                    // if (originalMemberId === undefined) {
                    //   console.log(memberDataModel)
                    // }
                    const inputFilePath = `${entryPointId}.${compoundId}.${originalMemberId}.md`;
                    const permalink = `${baseUrl}${outputFolderPath}/${entryPointId}/${compoundCategoryId}/${compoundId}/${memberId}`;
                    if (memberKind !== 'CallSignature') {
                        // if(originalMemberId === undefined) {
                        //   console.log(memberDataModel)
                        // }
                        permalinksMapByPath.set(inputFilePath, permalink);
                    }
                    const frontMatterSlug = `/api/${entryPointId}/${compoundCategoryId}/${compoundId}/${memberId}`;
                    if (memberKind === 'Method') {
                        memberTitle += '()';
                    }
                    let titleKind = memberKind;
                    if (titleKind === 'PropertySignature') {
                        titleKind = 'Property';
                    }
                    let escapedMemberId = memberId;
                    // Docusaurus ignores files that start with an underscore.
                    // Surround with $ if the original name contains non-alphanumeric characters
                    if (originalMemberId.startsWith('_')) {
                        escapedMemberId = `$${escapedMemberId}$`;
                    }
                    const frontMatterTitle = memberKind !== 'Constructor'
                        ? `${compoundLabel}.${memberTitle} ${titleKind.toLowerCase()}`
                        : `${compoundLabel}.${memberTitle}`;
                    const sidebarLabel = memberTitle;
                    const sidebarId = `${apiRelativeFolderPath}/${entryPointId}/${compoundCategoryId}/${compoundId}/${escapedMemberId}`;
                    const outputFilePath = `${entryPointId}/${compoundCategoryId}/${compoundId}/${escapedMemberId}.md`;
                    const member = {
                        kind: memberKind,
                        inputFilePath,
                        permalink,
                        frontMatterSlug,
                        frontMatterTitle,
                        sidebarLabel,
                        sidebarId,
                        outputFilePath,
                        data: memberDataModel,
                    };
                    if (memberId === undefined) {
                        member.isHidden = true;
                    }
                    let membersArray = compound.membersMap.get(member.kind);
                    if (membersArray === undefined) {
                        membersArray = [];
                        compound.membersMap.set(member.kind, membersArray);
                    }
                    membersArray.push(member);
                }
            }
        }
    }
    // for (const [keyPath, permalink] of permalinksMapByPath) {
    //   console.log(keyPath, '=>', permalink)
    // }
    return {
        topIndex,
        entryPointsSet,
        permalinksMapByPath,
    };
}
// ----------------------------------------------------------------------------
//# sourceMappingURL=tsdoc2docusaurus.js.map